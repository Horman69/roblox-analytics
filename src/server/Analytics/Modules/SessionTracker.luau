local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local HttpService = game:GetService("HttpService")

export type SessionData = {
    userId: number,
    playerName: string,
    sessionStart: number,
    lastActive: number,
    checkpoints: {[string]: number},
    deaths: number,
    dropReason: string?,
    duration: number?
}

local SessionTracker = {}
SessionTracker.__index = SessionTracker

-- –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
local _activeSessions: {[number]: SessionData} = {}
local _analyticsStore = DataStoreService:GetDataStore("GameAnalytics")

-- –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç—Ä–µ–∫–µ—Ä–∞
function SessionTracker.new()
    local self = setmetatable({}, SessionTracker)
    -- –ò—Å–ø–æ–ª—å–∑—É–µ–º WaitForChild –¥–ª—è –Ω–∞–¥—ë–∂–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥–∞
    self._config = require(script.Parent.Parent:WaitForChild("Config"):WaitForChild("AnalyticsSettings"))
    return self
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π
function SessionTracker:getAllSessions(): {[number]: SessionData}
    return _activeSessions
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Å–µ—Å—Å–∏–∏
function SessionTracker:getSession(player: Player): SessionData?
    if not player then return nil end
    return _activeSessions[player.UserId]
end

function SessionTracker:startTracking(player: Player): SessionData?
    if not player then 
        warn("‚ö†Ô∏è [SessionTracker] –ü–æ–ª—É—á–µ–Ω nil player –≤ startTracking")
        return nil
    end

    local session: SessionData = {
        userId = player.UserId,
        playerName = player.Name,
        sessionStart = os.time(),
        lastActive = os.time(),
        checkpoints = {},
        deaths = 0
    }
    
    _activeSessions[player.UserId] = session
    self:_logEvent("SESSION_START", player)
    return session
end

function SessionTracker:updateActivity(player: Player, checkpointId: string?)
    if not player then return end
    
    local session = _activeSessions[player.UserId]
    if session then
        session.lastActive = os.time()
        if checkpointId then
            session.checkpoints[checkpointId] = os.time()
            self:_logEvent("CHECKPOINT_REACHED", player, {checkpoint = checkpointId})
        end
    end
end

function SessionTracker:endTracking(player: Player, reason: string?)
    if not player then return end
    
    local session = _activeSessions[player.UserId]
    if session then
        session.duration = os.time() - session.sessionStart
        session.dropReason = reason
        
        self:_saveSession(session)
        _activeSessions[player.UserId] = nil
        self:_logEvent("SESSION_END", player, {
            duration = session.duration,
            reason = reason
        })
    end
end

-- –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã
function SessionTracker:_logEvent(eventType: string, player: Player, data: any?)
    if not self._config.DEBUG_MODE then return end
    
    local logMessage = string.format(
        "üìä [%s] %s | Player: %s | Data: %s",
        eventType,
        os.date("%H:%M:%S"),
        player.Name,
        data and HttpService:JSONEncode(data) or "none"
    )
    
    print(logMessage)
end

function SessionTracker:_saveSession(session: SessionData)
    if not session then return end
    
    local success, err = pcall(function()
        local sessionKey = string.format(
            "session_%d_%d",
            session.userId,
            session.sessionStart
        )
        
        _analyticsStore:SetAsync(sessionKey, session)
        self:_logEvent("SESSION_SAVED", {UserId = session.userId, Name = session.playerName})
    end)
    
    if not success then
        warn("‚ö†Ô∏è [SessionTracker] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏:", err)
    end
end

return SessionTracker